using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Lab6
{
    /*
     * В интерфейсах определяется какое то дополнительное поведение для объектов класса.
     * В самом классе такие методы не реализуются, потому что могут быть еще классы, у которых тоже может быть реализовано такое поведение.
     * Например, покормить можно и человека, домашнее животное и пр.
     * В повышенном уровне необходимо реализовать два метода с одинаковым названием. При этом у них должны быть и принимаемые параметры одинаковые.
     * В данном примере у методов названия одинаковые, в методы ничего не передается. Следовательно, теперь нужно понять как их отличать...
     * Обязательно необходима реализация всех членов интерфеса в том классе, который наследует данный интерфейс.
     */
    interface IFeedable
    {
        void Change();
    }
    interface INamed
    {
        string Name { get; }
        void Change();
    }

    /*
     * Определение делегата. Обозначается какие методы сможет запускать делегат.
     * То есть только те методы, у которых возвращаемый тип и параметры совпадают с делегатом.
     */
    delegate void AnimalHandler();

    abstract class Animal : IFeedable, INamed // классы могут наследоваться сразу от нескольких интерфейсов, но только от одного класса
    {
        //Создание переменной делегата
        AnimalHandler animalActions;
        /*
         * С помощью метода будем запускать делегат. 
         * В примере сделано так, чтобы не было прямого доступа к делегату, следовательно нельзя будет извне изменить методы, которые запускает делегат.
         * Перед запуском необходимо проверить, есть ли в делегате ссылки на методы. Если их не будет, то программа выкинет исключение.
         * Можно сделать двумя способами:
         */
        public void Action()
        {
            animalActions?.Invoke();
            //if (animalActions != null)
            //    animalActions();
        }
        /* 
         * Метод в котором будет добавление всех методов в делегат. Такое можно и по другому организовать.
         * В делегат добавляются ссылки на методы (пишется только НАЗВАНИЕ метода) с помощью +=, удаляются с помощью -=
         * Можно один метод несколько раз добавить, выполнится он тоже несколько раз.
         * Знак = переприсваивает ссылки.
         */
        void AnimalActionsAdd()
        {
            /*
             * В случае с методами интерфеса, у которых указан сам интерфейс, из которого этот метод берется,
             * необходимо сначала привести объект к типу интерфеса, потом уже доставать метод.
             */
            IFeedable feedable = (IFeedable)this;
            animalActions = Pet;
            animalActions += feedable.Change;
            animalActions += Sound;
        }

        string habitat;
        double weight;

        protected Animal()
        {
            Habitat = "Неизвестно";
            Weight = 1;
            /*
             * Добавляем в делегат ссылки на методы. обычно это делается в момент создания объекта один раз.
             * Очень часто делают такую ошибку, что добавляют ссылки где то при вызове какого то метода, 
             * и получается так, что в делегате копятся ссылки на один и тот же метод. И запускает делегат тоже этот метод несколько раз.
             */
            AnimalActionsAdd();
        }

        protected Animal(string habitat, double weight)
        {
            Habitat = habitat;
            Weight = weight;
            AnimalActionsAdd();
        }

        public double Weight
        {
            get { return weight; }
            set
            {
                if (value <= 0)
                    throw new ArgumentException("Вес не можеть быть меньше или равен 0");
                weight = value;
            }
        }
        /* 
         * Такое свойство можно сделать с помощью контекстного меню по полю,
         * выбрать "быстрые действия и рефакторинг",
         * далее "инкапсулировать поле ... (и использовать свойство)"
         */
        public string Habitat { get => habitat; set => habitat = value; }

        /*  
         *  Метод ToString находится в базовом для всех классе - object.
         *  Это виртуальный метод, поэтому его можно переопределить в любом классе.
         *  Для всех дочерних классов вызывается еще и метод родительского, чтобы выводить информацию из него.
         *  Метод можно вызывать самостоятельно ("название объекта".ToString()) 
         *  или передав объект в метод вывода из класса Console (Console.WriteLine("название объекта")
         */
        public override string ToString()
        {
            return "Ареал обитания: " + Habitat + "\nВес: " + Weight + (Name != null ? ("\nИмя животного: " + Name) : "");
        }

        /*
         * Объявление абстрактного метода.
         * Реализация обязательна во ВСЕХ дочерних классах, которые непосредственно наследуются от абстарктного класса.
         * Такой метод подойдет, если у всех дочерних объектов разная реализация одного и того же действия
         */
        public abstract void Sound();

        /*
         * Объявление и реализация вирутального метода.
         * Такие методы можно не переопределять в дочерних классах, ошибки не будет.
         * Но создаются они с целью, если нужна в некоторых (или во всех) классах другая реализация (полностью или частично).
         * В примерах сначала вызывается базовый виртуальный метод, потом идет выполнение кода описанный ниже после вызова.
         */
        public virtual void Pet()
        {
            Console.WriteLine("Вы гладите животное...");
        }

        /*
         * При реализации методов из разных интерфесов, но с одинаковым названием и сигнатурой необходимо указывать, из какого интерфеса метод.
         * При использовании методов необходимо объект класса приводить к типу интерфеса и у приведенного объекта вызывать метод.
         */
        void IFeedable.Change()
        {
            Console.WriteLine("Вы покормили животное. Его вес увеличился на 1");
            Weight = Weight + 1;
        }
        void INamed.Change()
        {
            Console.Write("Введите имя животного: ");
            string _name = Console.ReadLine();
            if (_name != "")
                name = _name;
            else
                Console.WriteLine("Вы не ввели имя!");
        }
        string name;
        public string Name { get { return name; } }
    }
}
